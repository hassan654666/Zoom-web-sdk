/* Here, in this code the PIP is working perfectly but the zoom app container is not in full screen view in react native web view or in a desktop browser, and hence not all of the Zoom UI buttons are in view. It also doesn't support rotate screen in the web view. Make it so that the only place I can see my own tile is the PIP and rest of the user tiles are visible in the zoom app container that takes full screen. If there are more than one other users and all have their camera on, they should appear stacked, if only one other person has their camera on, they should take the full screen. Also make sure the zoom UI buttons take no more or less than the device width and are visible at the bottom of the screen in both gallery and minimized view. Also please don't add or change anything in the meeting client generation and joining logic, and meeting leave/end and notify logic, that part is working perfectly now. */ 
<!DOCTYPE html> 
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
    <title>Zoom Meeting</title>

    <!-- Zoom SDK -->
    <script src="https://source.zoom.us/3.12.0/lib/vendor/react.min.js"></script>
    <script src="https://source.zoom.us/3.12.0/lib/vendor/react-dom.min.js"></script>
    <script src="https://source.zoom.us/3.12.0/lib/vendor/redux.min.js"></script>
    <script src="https://source.zoom.us/3.12.0/lib/vendor/redux-thunk.min.js"></script>
    <script src="https://source.zoom.us/3.12.0/lib/vendor/lodash.min.js"></script>
    <script src="https://source.zoom.us/3.12.0/zoom-meeting-embedded-3.12.0.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        #meetingContainer {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            background: #000;
        }

        #meetingSDKElement {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Minimal styling - let Zoom handle most layout */
        .self-video-pip {
            position: fixed !important;
            bottom: 20px !important;
            right: 20px !important;
            width: 120px !important;
            height: 160px !important;
            z-index: 1000 !important;
            border: 2px solid #fff !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5) !important;
            overflow: hidden !important;
        }

        /* Hide the original self video from gallery */
        .self-video-original {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 18px;
            z-index: 1001;
        }

        #error {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            padding: 20px;
            z-index: 1002;
        }

        .retry-btn {
            background: #2D8CFF;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            margin-top: 20px;
            cursor: pointer;
            font-size: 16px;
        }

        /* Landscape orientation */
        @media (orientation: landscape) {
            .self-video-pip {
                width: 160px !important;
                height: 120px !important;
            }
        }
    </style>
</head>
<body>
    <div id="meetingContainer">
        <div id="meetingSDKElement"></div>
    </div>
    
    <div id="loading">
        Joining meeting...
    </div>

    <div id="error">
        <h2>Unable to Join Meeting</h2>
        <p id="errorMessage"></p>
        <button class="retry-btn" onclick="retryJoin()">Try Again</button>
    </div>

    <script>
        // Get parameters from URL
        const params = new URLSearchParams(window.location.search);
        const meetingNumber = params.get("meetingNumber");
        const signature = decodeURIComponent(params.get("signature") || "");
        const sdkKey = params.get("sdkKey");
        const userName = decodeURIComponent(params.get("name") || "Guest");
        const password = decodeURIComponent(params.get("password") || "").trim();

        let zoomClient = null;
        let observer = null;
        let selfVideoPIP = null;
        let isInitialized = false;

        // Start meeting when page loads
        window.addEventListener('DOMContentLoaded', startMeeting);

        // Handle screen orientation changes
        window.addEventListener('orientationchange', updatePIPSize);
        window.addEventListener('resize', updatePIPSize);

        async function startMeeting() {
            try {
                // Validate required parameters
                if (!meetingNumber || !signature || !sdkKey) {
                    throw new Error('Missing meeting parameters');
                }

                console.log('Starting Zoom meeting...');

                // Check if Zoom SDK is loaded
                if (typeof window.ZoomMtgEmbedded === 'undefined') {
                    throw new Error('Zoom SDK not loaded');
                }

                // Create Zoom client
                zoomClient = window.ZoomMtgEmbedded.createClient();

                // Initialize Zoom - let Zoom handle the layout
                await zoomClient.init({
                    zoomAppRoot: document.getElementById('meetingSDKElement'),
                    language: 'en-US',
                    patchJsMedia: true
                    // No customizations - let Zoom handle layout
                });

                // Set up meeting end listener
                zoomClient.on('connection-change', (payload) => {
                    if (payload.state === 'Closed') {
                        notifyAppAndClose();
                    }
                });

                // Listen for video state changes
                zoomClient.on('user-updated', handleUserUpdate);

                // Join meeting
                await zoomClient.join({
                    sdkKey: sdkKey,
                    signature: signature,
                    meetingNumber: meetingNumber,
                    password: password,
                    userName: userName
                });

                console.log('âœ… Successfully joined meeting');
                
                // Hide loading screen
                document.getElementById('loading').style.display = 'none';

                // Start observing for self video
                setTimeout(startVideoObservation, 2000);

                isInitialized = true;

            } catch (error) {
                console.error('Meeting error:', error);
                showError(error.message);
            }
        }

        function handleUserUpdate(payload) {
            // When user video state changes, update PIP
            if (payload && payload.user) {
                setTimeout(createSelfVideoPIP, 500);
            }
        }

        function startVideoObservation() {
            // Use a more gentle observer with debouncing
            observer = new MutationObserver(() => {
                // Debounce to prevent flickering
                clearTimeout(window.videoUpdateTimeout);
                window.videoUpdateTimeout = setTimeout(createSelfVideoPIP, 300);
            });

            observer.observe(document.getElementById('meetingSDKElement'), {
                childList: true,
                subtree: true,
                attributes: false, // Don't observe attributes to reduce flickering
                childList: true
            });

            // Initial setup
            createSelfVideoPIP();
        }

        function createSelfVideoPIP() {
            if (!isInitialized) return;

            try {
                const meetingElement = document.getElementById('meetingSDKElement');
                if (!meetingElement) return;

                // Find all video elements
                const videoElements = meetingElement.querySelectorAll('video');
                let selfVideoElement = null;

                // Try to identify self video
                videoElements.forEach(video => {
                    // Look for videos that are playing (self video usually starts playing first)
                    if (video.readyState > 0 && !video.paused && !video.muted) {
                        // Additional check: look for video that matches our user context
                        const container = video.closest('[class*="video-container"]');
                        if (container) {
                            const containerText = container.innerText || '';
                            if (containerText.includes(userName) || 
                                container.getAttribute('data-self') === 'true' ||
                                !selfVideoElement) {
                                selfVideoElement = video;
                            }
                        }
                    }
                });

                // Fallback: use first video if no self video found
                if (!selfVideoElement && videoElements.length > 0) {
                    selfVideoElement = videoElements[0];
                }

                if (selfVideoElement && !selfVideoPIP) {
                    createPIPElement(selfVideoElement);
                } else if (selfVideoElement && selfVideoPIP) {
                    // Update existing PIP with new video stream if needed
                    updatePIPVideo(selfVideoElement);
                }

            } catch (error) {
                console.log('PIP creation error:', error);
            }
        }

        function createPIPElement(originalVideo) {
            // Create a new video element for PIP
            selfVideoPIP = document.createElement('video');
            selfVideoPIP.className = 'self-video-pip';
            selfVideoPIP.autoplay = true;
            selfVideoPIP.muted = true;
            selfVideoPIP.playsInline = true;

            // Copy the video stream
            if (originalVideo.srcObject) {
                selfVideoPIP.srcObject = originalVideo.srcObject;
            } else if (originalVideo.src) {
                selfVideoPIP.src = originalVideo.src;
            }

            // Add to body
            document.body.appendChild(selfVideoPIP);

            // Mark original video as hidden (but don't remove it - Zoom needs it)
            const originalContainer = originalVideo.closest('[class*="video-container"]');
            if (originalContainer) {
                originalContainer.classList.add('self-video-original');
            }

            console.log('âœ… Created self video PIP');
        }

        function updatePIPVideo(originalVideo) {
            if (!selfVideoPIP) return;

            // Update PIP with current video stream
            if (originalVideo.srcObject && selfVideoPIP.srcObject !== originalVideo.srcObject) {
                selfVideoPIP.srcObject = originalVideo.srcObject;
            }
        }

        function updatePIPSize() {
            if (!selfVideoPIP) return;

            if (window.innerHeight > window.innerWidth) {
                // Portrait
                selfVideoPIP.style.width = '120px';
                selfVideoPIP.style.height = '160px';
            } else {
                // Landscape
                selfVideoPIP.style.width = '160px';
                selfVideoPIP.style.height = '120px';
            }
        }

        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('error').style.display = 'flex';
            document.getElementById('errorMessage').textContent = message;
        }

        function retryJoin() {
            document.getElementById('error').style.display = 'none';
            document.getElementById('loading').style.display = 'flex';
            
            // Clean up
            if (observer) {
                observer.disconnect();
            }
            if (selfVideoPIP) {
                selfVideoPIP.remove();
                selfVideoPIP = null;
            }
            
            isInitialized = false;
            setTimeout(startMeeting, 1000);
        }

        function notifyAppAndClose() {
            // Clean up
            if (observer) {
                observer.disconnect();
            }
            if (selfVideoPIP) {
                selfVideoPIP.remove();
            }

            // Notify React Native app that meeting ended
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(
                    JSON.stringify({ action: 'meetingEnded' })
                );
            }
            
            // Fallback for browser testing
            setTimeout(() => {
                alert('Meeting ended. You can close this window.');
            }, 500);
        }

        // Global error handling
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
        });

    </script>
</body>
</html>